(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{631:function(t,r,a){"use strict";a.r(r);var s=a(6),e=Object(s.a)({},(function(){var t=this,r=t.$createElement,a=t._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("版本：2.2.4")]),t._v(" "),a("h2",{attrs:{id:"概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[t._v("#")]),t._v(" 概念")]),t._v(" "),a("h3",{attrs:{id:"面向切面编程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面向切面编程"}},[t._v("#")]),t._v(" 面向切面编程")]),t._v(" "),a("p",[a("strong",[t._v("在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想")]),t._v("就是面向切面编程。")]),t._v(" "),a("p",[t._v("面向对象编程的特点是继承、封装和多态。封装的要求就是职责分配，也即让不同的类设计不同的方法，这样代码就分散到一个个的类中去了，这样的好处是降低了代码的复杂程度，使类可重用。但是分散代码的同时，也增加了代码的重复性。例如在两个类中都需要做日志，但按照面向对象的设计方法，由于两个类之间无法联系，就必须在两个类的方法中都加入日志的内容，虽然他们是完全相同的，但还是无法将这些重复的代码统一起来。进一步想如果将日志方法封装进独立的类独立的方法中，然后在两个类中调用，这种处理又会导致这两个类与日志的独立类发生耦合，日志类的改变就会影响这两个类。")]),t._v(" "),a("p",[t._v("那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？ -> 面向切面编程。")]),t._v(" "),a("p",[t._v("一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了 AOP，我们就可以把几个类共有的方法，抽取到一个切片中，等到需要时在切入对象中去，从而改变其原有的行为。")]),t._v(" "),a("p",[t._v("这样看 APO 其实只是 OOP 的补充而已。OOP 从横向区分出一个个类来，AOP 则从纵向上向对象中加入特定的代码，有了 AOP，OOP 变得立体了。")]),t._v(" "),a("p",[a("strong",[t._v("从技术上来说，AOP 基本上是通过代理机制实现的")]),t._v("。")]),t._v(" "),a("h2",{attrs:{id:"内容"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内容"}},[t._v("#")]),t._v(" 内容")]),t._v(" "),a("p",[t._v("博客： "),a("a",{attrs:{href:"https://www.cnblogs.com/didispace/tag/spring%20boot/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Spring Boot 2.X 基础教程"),a("OutboundLink")],1)])])}),[],!1,null,null,null);r.default=e.exports}}]);